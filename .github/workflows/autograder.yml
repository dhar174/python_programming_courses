name: Autograder

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

jobs:
  grade:
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare autograder configuration
        run: |
          mkdir -p submission/.github/autograder
          cp Basics/assignments/Basics_Day1_homework.ipynb submission/Basics_Day1_homework.ipynb
          cp Basics/assignments/Basics_Day1_homework.ipynb submission/.github/autograder/Basics_Day1_homework.ipynb
          cp Basics/assignments/Basics_Day1_homework/criteria.json submission/.github/autograder/criteria.json
          cp Basics/assignments/Basics_Day1_homework/feedback.json submission/.github/autograder/feedback.json
          test -f submission/Basics_Day1_homework.ipynb || (echo "Missing copied submission/Basics_Day1_homework.ipynb" && exit 1)
          test -f submission/.github/autograder/Basics_Day1_homework.ipynb || (echo "Missing copied Basics_Day1_homework.ipynb" && exit 1)
          test -f submission/.github/autograder/criteria.json || (echo "Missing copied criteria.json" && exit 1)
          test -f submission/.github/autograder/feedback.json || (echo "Missing copied feedback.json" && exit 1)
          cat << 'EOF' > submission/.github/autograder/setup.json
          {
            "file_checks": ["Basics_Day1_homework.ipynb"],
            "commands": [
              "python -m pip install --quiet --upgrade pip",
              "python -m pip install nbconvert",
              "jupyter nbconvert --to script Basics_Day1_homework.ipynb --output day1",
              "if [ ! -f day1.py ]; then echo 'ERROR: Conversion failed'; exit 1; fi"
            ]
          }
          EOF
          test -f submission/.github/autograder/setup.json || (echo "Missing generated setup.json" && exit 1)
      
      - name: Run autograder
        uses: webtech-network/autograder@v1
        with:
          template_preset: 'io'
          feedback-type: 'default'

      - name: Summarize assignment grading results
        run: |
          python - << 'PY'
          import json
          import os
          import sys
          from pathlib import Path

          output_dir = Path("submission/.github/autograder")
          output_dir.mkdir(parents=True, exist_ok=True)

          assignment_results = []
          granular_files = []
          ignored_names = {"criteria.json", "feedback.json", "setup.json", "quiz_grades.json", "assignment_grades.json"}

          for json_path in sorted(output_dir.rglob("*.json")):
              if json_path.name in ignored_names:
                  continue
              if "_Quiz_" in json_path.name:
                  continue
              try:
                  payload = json.loads(json_path.read_text(encoding="utf-8"))
              except json.JSONDecodeError:
                  continue
              tests = payload.get("tests") if isinstance(payload, dict) else None
              if not isinstance(tests, list) or not tests:
                  continue
              if not any(isinstance(test, dict) and ("pass" in test or "student_stdout" in test) for test in tests):
                  continue

              total_points = 0.0
              score_points = 0.0
              for test in tests:
                  if not isinstance(test, dict):
                      continue
                  try:
                      points = float(test.get("points", 1))
                  except (TypeError, ValueError):
                      points = 1.0
                  total_points += points
                  if test.get("pass") is True:
                      score_points += points

              assignment_results.append(
                  {
                      "assignment_id": json_path.stem.replace("_criteria", ""),
                      "score": score_points,
                      "total": total_points,
                      "source_file": str(json_path),
                  }
              )
              granular_files.append(json_path)

          results_file = output_dir / "assignment_grades.json"
          results_file.write_text(json.dumps({"assignments": assignment_results}, indent=2), encoding="utf-8")
          print(f"Wrote assignment grading report to {results_file}")

          for granular_file in granular_files:
              try:
                  granular_file.unlink()
              except OSError as exc:
                  print(f"Warning: could not remove granular assignment file {granular_file}: {exc}", file=sys.stderr)

          summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
          if summary_file:
              lines = ["## Assignment grading results", "", "| Assignment | Score | Source |", "| --- | --- | --- |"]
              if assignment_results:
                  for result in assignment_results:
                      lines.append(f"| {result['assignment_id']} | {result['score']}/{result['total']} | {result['source_file']} |")
              else:
                  lines.append("| _No assignment results found_ | 0/0 | n/a |")
              try:
                  with open(summary_file, "a", encoding="utf-8") as handle:
                      handle.write("\n".join(lines) + "\n")
              except OSError as exc:
                  print(f"Warning: could not write GitHub step summary: {exc}", file=sys.stderr)
          PY

      - name: Grade Basics HTML quizzes
        run: |
          python - << 'PY'
          import json
          import os
          import sys
          from pathlib import Path

          QUIZ_HTML_PATHS = {
              "Basics_Day1_Quiz": [
                  Path("Basics/quizzes/Basics_Day1/Basics_Day1_Quiz.html"),
                  Path("Basics/quizzes/Basics_Day1_Quiz.html"),
              ],
              "Basics_Day2_Quiz": [
                  Path("Basics/quizzes/Basics_Day2/Basics_Day2_Quiz.html"),
                  Path("Basics/quizzes/Basics_Day2_Quiz.html"),
              ],
          }

          output_dir = Path("submission/.github/autograder")
          output_dir.mkdir(parents=True, exist_ok=True)
          quiz_results = []
          UNANSWERED_MARKER = "unanswered"

          for legacy_file in output_dir.glob("*_Quiz_criteria.json"):
              legacy_file.unlink(missing_ok=True)

          def load_quiz_data(html_path: Path) -> dict:
              html = html_path.read_text(encoding="utf-8")
              start_marker = "const QUIZ_DATA = "
              end_marker = ";\n    const STORAGE_KEY"
              start = html.find(start_marker)
              end = html.find(end_marker, start if start >= 0 else 0)
              if start < 0 or end < 0:
                  raise ValueError(f"Unable to parse QUIZ_DATA from {html_path}")
              quiz_data_json = html[start + len(start_marker):end]
              try:
                  return json.loads(quiz_data_json)
              except json.JSONDecodeError as exc:
                  raise ValueError(f"Malformed QUIZ_DATA JSON in {html_path}: {exc}") from exc

          def load_student_answers(quiz_id: str, html_path: Path) -> tuple[dict, str]:
              candidates = [
                  html_path.with_name(f"{quiz_id}_answers.json"),
                  html_path.with_name(f"{quiz_id.lower()}_answers.json"),
                  Path(f"Basics/quizzes/{quiz_id}_answers.json"),
              ]
              for candidate in candidates:
                  if not candidate.exists():
                      continue
                  try:
                      payload = json.loads(candidate.read_text(encoding="utf-8"))
                      answers = payload.get("student_answers") if isinstance(payload, dict) else None
                      if isinstance(answers, dict):
                          return {str(k): str(v) for k, v in answers.items()}, str(candidate)
                  except json.JSONDecodeError:
                      continue
              return {}, "missing_submission"

          for quiz_id, candidates in QUIZ_HTML_PATHS.items():
              html_path = next((path for path in candidates if path.exists()), None)
              if html_path is None:
                  missing = ", ".join(str(path) for path in candidates)
                  print(f"Missing HTML quiz file for {quiz_id}. Tried: {missing}")
                  sys.exit(1)

              try:
                  quiz_data = load_quiz_data(html_path)
              except ValueError as exc:
                  print(f"Failed to load quiz data for {quiz_id} from {html_path}: {exc}")
                  sys.exit(1)
              expected_answers = quiz_data.get("expectedAnswers")
              if not isinstance(expected_answers, dict) or not expected_answers:
                  print(f"Quiz {quiz_id} is missing expectedAnswers in {html_path}")
                  sys.exit(1)
              if not all(str(question_id).isdigit() for question_id in expected_answers):
                  print(f"Quiz {quiz_id} has non-numeric question IDs in expectedAnswers")
                  sys.exit(1)

              student_answers, answer_source = load_student_answers(quiz_id, html_path)
              if not all(str(question_id).isdigit() for question_id in student_answers):
                  print(f"Quiz {quiz_id} has non-numeric keys in student_answers")
                  sys.exit(1)
              unexpected_keys = set(student_answers) - set(expected_answers)
              if unexpected_keys:
                  print(f"Quiz {quiz_id} student_answers include unknown question IDs: {sorted(unexpected_keys)}")
                  sys.exit(1)
              tests = []
              score = 0
              for question_id in sorted(expected_answers, key=lambda qid: int(qid)):
                  expected = str(expected_answers[question_id])
                  actual_value = student_answers.get(question_id)
                  actual = str(actual_value) if actual_value is not None else UNANSWERED_MARKER
                  passed = actual == expected
                  score += int(passed)
                  tests.append(
                      {
                          "name": f"{quiz_id} Question {question_id}",
                          "points": 1,
                          "expected_stdout": [expected],
                          "student_stdout": [actual],
                          "pass": passed,
                      }
                  )

              quiz_results.append(
                  {
                      "quiz_id": quiz_id,
                      "quiz_html": str(html_path),
                      "answer_source": answer_source,
                      "score": score,
                      "total": len(expected_answers),
                      "tests": tests,
                  }
              )

          results_file = output_dir / "quiz_grades.json"
          results_file.write_text(json.dumps({"quizzes": quiz_results}, indent=2), encoding="utf-8")
          print(f"Wrote quiz grading report to {results_file}")

          summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
          if summary_file:
              lines = ["## Quiz grading results", "", "| Quiz | Score | Answer source |", "| --- | --- | --- |"]
              for result in quiz_results:
                  lines.append(f"| {result['quiz_id']} | {result['score']}/{result['total']} | {result['answer_source']} |")
              try:
                  with open(summary_file, "a", encoding="utf-8") as handle:
                      handle.write("\n".join(lines) + "\n")
              except OSError as exc:
                  print(f"Warning: could not write GitHub step summary: {exc}", file=sys.stderr)
          PY

      - name: Commit and push autograder results
        id: commit_results
        if: github.event_name == 'workflow_dispatch'
        run: |
          set -euo pipefail
          DATETIME="$(date -u +%Y%m%d-%H%M%S)"
          BRANCH_NAME="autograder-results-${DATETIME}"

          git config user.name "github-actions[bot]" || { echo "Failed to configure git user.name"; exit 1; }
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || { echo "Failed to configure git user.email"; exit 1; }
          git add -A || { echo "Failed to stage autograder outputs"; exit 1; }

          if git diff --cached --quiet; then
            echo "No autograder output changes detected; skipping commit and push."
            exit 0
          fi

          git checkout -b "${BRANCH_NAME}" HEAD || { echo "Failed to create branch ${BRANCH_NAME}"; exit 1; }
          git commit -m "Autograder results on ${DATETIME}" || { echo "Failed to commit autograder outputs"; exit 1; }
          git push origin "${BRANCH_NAME}" || { echo "Failed to push branch ${BRANCH_NAME}"; exit 1; }
          echo "branch_name=${BRANCH_NAME}" >> "$GITHUB_OUTPUT"

      - name: Print autograder results branch
        if: steps.commit_results.outcome == 'success' && steps.commit_results.outputs.branch_name != ''
        run: |
          echo "Autograder results branch: ${{ steps.commit_results.outputs.branch_name }}"

  grade_pr:
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate autograder source configuration
        run: |
          test -f Basics/assignments/Basics_Day1_homework.ipynb
          test -f Basics/assignments/Basics_Day1_homework/criteria.json
          test -f Basics/assignments/Basics_Day1_homework/feedback.json
          python - << 'PY'
          import json
          import sys
          from pathlib import Path
          QUIZ_HTML_PATHS = {
              "Basics_Day1_Quiz": [
                  Path("Basics/quizzes/Basics_Day1/Basics_Day1_Quiz.html"),
                  Path("Basics/quizzes/Basics_Day1_Quiz.html"),
              ],
              "Basics_Day2_Quiz": [
                  Path("Basics/quizzes/Basics_Day2/Basics_Day2_Quiz.html"),
                  Path("Basics/quizzes/Basics_Day2_Quiz.html"),
              ],
          }
          try:
              criteria = json.loads(Path('Basics/assignments/Basics_Day1_homework/criteria.json').read_text())
          except json.JSONDecodeError as exc:
              print(f'criteria.json is invalid JSON: {exc}')
              sys.exit(1)
          try:
              feedback = json.loads(Path('Basics/assignments/Basics_Day1_homework/feedback.json').read_text())
          except json.JSONDecodeError as exc:
              print(f'feedback.json is invalid JSON: {exc}')
              sys.exit(1)
          if not isinstance(criteria.get('tests'), list):
              print('criteria.json must contain a tests array')
              sys.exit(1)
          if not isinstance(feedback, dict):
              print('feedback.json must be a JSON object')
              sys.exit(1)
          for quiz_id, candidates in QUIZ_HTML_PATHS.items():
              quiz_path = next((candidate for candidate in candidates if candidate.exists()), None)
              if quiz_path is None:
                  print(f'Missing HTML quiz for {quiz_id}. Tried: {", ".join(str(path) for path in candidates)}')
                  sys.exit(1)
              html = quiz_path.read_text(encoding='utf-8')
              start_marker = "const QUIZ_DATA = "
              end_marker = ";\n    const STORAGE_KEY"
              start = html.find(start_marker)
              end = html.find(end_marker, start if start >= 0 else 0)
              if start < 0 or end < 0:
                  print(f'{quiz_path} must define const QUIZ_DATA')
                  sys.exit(1)
              try:
                  quiz_data = json.loads(html[start + len(start_marker):end])
              except json.JSONDecodeError as exc:
                  print(f'{quiz_path} has invalid QUIZ_DATA JSON: {exc}')
                  sys.exit(1)
              expected = quiz_data.get('expectedAnswers')
              if not isinstance(expected, dict) or not expected:
                  print(f'{quiz_path} must include non-empty expectedAnswers')
                  sys.exit(1)
          print('Autograder source configuration files passed basic JSON structure checks.')
          PY
